
// *****   HEX DEMO APP ....

var _dbClient = null; // USE setModuleDependencies() to pass in an active client before using this module....
var _fs = null; 
var _xml2js = null;
var _ObjectID = null; 
var _dbConnStr = ''; // set in config....

var _dbConnection = null;  


var _userCollection = "users";

// NOT NEEDED FOR HEX DEMO.... 
var _colName = "TUT_OBS";
var _hccIcd9Collection = "HCC_ICD";
var _flowsheetColection = "CKT_FLOWSHEETS";
var _accountCollection = "accounts";
var _ordersCollection = "orders";
var _logCollection = "log";
var _logUICollection = "log_UI_EVENTS";
var _logicCollection = "logic_components";
var _probDurationCollection = "problem_duration";
var _icd10DescriptionCollection = "icd10";
var _systemAlertsCollection = "system_alerts";
var _obsHeadJsonList = null; 

exports.setModuleDependencies=function( config, dbClient, fs, xml2js, ObjectID ){
		// CALLED BY app.js DURING APP SETUP.....
		_config = config;
		_dbConnStr = config.database.connection;
		_dbClient = dbClient;
		_fs = fs;
		_xml2js = xml2js;
		_ObjectID = ObjectID;
};//end function....



exports.getUserAccountInfo = function( userName, pCallback ){
	var callback = function( result ){
		pCallback( result );
	}
	var collection = "users";
	var query = { userName: userName };
	var options = {_id:0 };
	genericFindRecordsInDatabase( collection, query, options, callback );
};

exports.getCounterDataForGame = function( gameId, pCallback ){
	var callback = function( result ){
		pCallback( result );
	}
	var collection = "counter_data";
	var query = { gameId: gameId };
	var options = {_id:0 };
	genericFindRecordsInDatabase( collection, query, options, callback );
};


// GET ACTIVE GAMES...
exports.getActiveGamesByUser = function( userName, pCallback ){
	var callback = function( result ){
		pCallback( result );
	}
	var collection = "active_games";
	var query = { "users.userName": userName };
	var options = {_id:0 };
	genericFindRecordsInDatabase( collection, query, options, callback );
};
//

exports.updateCounterData = function( gameId, counterObj, pCallback ){
	var counterId = counterObj.id;

	var callback_02 = function( result ){
		pCallback( result );
	}

	var callback_01 = function( result){
		// WE HAVE DELETED THE OLD COUNTER.
		// NOW INSERT THE NEW...
		var collection = "counter_data";
		var query = { gameId: gameId };
		var options = { $push: {"counters":counterObj}};// ADD NEW ITEM TO counters ARRAY....
		var isUpsert = true;
		genericUpdateRecordInDatabase( collection, query, options, isUpsert, callback_02 );
	};
	var collection = "counter_data";
	var query = { gameId: gameId };
	var options = { $pull: {"counters":{id:counterId} }};// REMOVE ALL ITEMS IN counters ARRAY MATCHING THIS id QUERY....
	var isUpsert = true;
	genericUpdateRecordInDatabase( collection, query, options, isUpsert, callback_01 );
};


exports.pingDatabase=function(){
	//genericFindRecordsInDatabase=function( collectionName, query, options, callback ){
	var callback = function( result ){
		console.log("PING RESULTS:", result);
	}
	var collection = "users";
	var query = {userName: "dvdgnzlz" };
	var options = {_id:0 };
	genericFindRecordsInDatabase( collection, query, options, callback );
}













exports.writeLogRecord=function( record ){
	//var genericInsertRecordsInDatabase=function( collectionName, data, callback ){
	var writeCallback = function( result ){

	}
	record.time = new Date();
	genericInsertRecordsInDatabase( _logCollection, record, writeCallback);
}



exports.writeLogRecord_UserInterfaceEvents=function( record ){
	record.time = new Date();
	var cb = function(){};
	genericInsertRecordsInDatabase( _logUICollection, record, cb);
};




exports.LoadMedClassTextTxt = function( filePath, app ){
	var medClassArr = [];
	var _printData = function(){
		for (var x=0; x<medClassArr.length; x++){
			var record = medClassArr[x];
			var spaces = Array(record.lvl).join(" ");//create string of once space per level....
			if (record.lvl<5){
				console.log( spaces + record.lvl + " " + record.gpi + "-" + record.max + " : " + record.desc );
				
			}
		}
	};
	var _fnParseFile_STEP_01 = function( err, dataTxt ){
		if (err) return; //error reading the file...
		console.log( "Parsing Med Class file...");
		var maxLevelArr = [null, null, null, null];//record the last record of level 1, 2, 3, and 4 in this array....
		var lastRecord = null;
		var lineArr = dataTxt.split('\r');
		var lineCnt = lineArr.length;

		for (var x=0; x<lineArr.length; x++){
			var line = lineArr[x];
			var data = line.split('\t');
			var medClassRecord = {};
			medClassRecord.lvl = Number.parseInt(data[0]);
			medClassRecord.gpi = data[1];
			medClassRecord.desc = data[2];
			medClassArr.push( medClassRecord );

			// record the max GPI for each parent item of equal or lower level....
			for( var y=medClassRecord.lvl; y<5; y++){
				var sibling = maxLevelArr[ y-1 ];
				if (lastRecord && lastRecord.lvl<medClassRecord.lvl){
					sibling = null;
				}
				if (sibling){
					sibling.max = medClassRecord.gpi;
				}
			}


			maxLevelArr[ medClassRecord.lvl-1 ]=medClassRecord; // save this record at the coresponding level...
			lastRecord = medClassRecord;
		}// END FOR LOOP...
		// SET MAX VALUES FOR LAST RECORDS....
		for (var x=0; x<maxLevelArr.length; x++){
			var lastRecord = maxLevelArr[x];
			lastRecord.max = "9999999999";
		}
		//_printData();
		console.log( JSON.stringify(medClassArr) );
	};//end function...
	// START BY READING THE FIRST
	_fs.readFile( filePath, 'utf8', _fnParseFile_STEP_01 );	
};

exports.LoadHccIcdTxt = function( filePath_ICD_HCC, filePath_HCC_WT, app ){

	// create object to store all data which can be used to deliver to clients...
	var _finalHccObj = {"HCC_GROUPS":[], "SEPARATOR":"=========================", "ICD_HCC_LIST":[]} ;
	var _hccArrForMongo = _finalHccObj.ICD_HCC_LIST;
	var _hccGroups = _finalHccObj.HCC_GROUPS; 

	var _objICD10ArraysOrgByGroup ={};//collection of ICD10 arrays organized by HCC group number...

	var _fnGetHCCGroupByNumber = function( grpNumber ){
		// GET AN ARRAY TO STORE ICD10 CODES FOR EACH UNIQUE grpNumber
		// STORE ALL ARRAYS IN _objICD10ArraysOrgByGroup object...
		var groupObj = []; // create array for ICD10 codes
		// find any existing group and use that one instead...
		var bFoundGroup = false;
		for (grpName in _objICD10ArraysOrgByGroup ){
			if (_objICD10ArraysOrgByGroup.hasOwnProperty(grpName) && grpName==grpNumber) {
				bFoundGroup = true;
				groupObj = _objICD10ArraysOrgByGroup[ grpName ]; //use the found group...
				//console.log( "FOUND " + grpNumber );
			}
		}
		if (!bFoundGroup){ // ADD NEW UNIQUE GROUP NUMBER....
			_objICD10ArraysOrgByGroup[ grpNumber ] = groupObj; 
			//console.log( "CREATED NEW GROUP: " + grpNumber );
		}
		return groupObj;
	};

	var _fnGetHCCDetailsByNumber = function( grpNumber){
		console.log( "GETTING " + grpNumber);
		for (var x=0; x<_hccGroups.length; x++){
			var hccRecord = _hccGroups[x];
			if (hccRecord.hcc == grpNumber ){
				console.log( "FOUND " + hccRecord.hcc );
				return hccRecord;
			}
		}
		return null;
	};

	var _display_objICD10ArraysOrgByGroup = function(){
		console.log( "====== _objICD10ArraysOrgByGroup =========");
		
		var outputObj = [];

		for (grpName in _objICD10ArraysOrgByGroup ){
			if (_objICD10ArraysOrgByGroup.hasOwnProperty(grpName) ) {
				var icdArr = _objICD10ArraysOrgByGroup[ grpName ]; //use the found group...
				var hccRecord = _fnGetHCCDetailsByNumber( grpName );
				if (hccRecord){
					hccRecord.icd10Arr = icdArr;
					outputObj.push( hccRecord );
				}
				//var hccRecord = {hcc: hccGroup, desc:hccDesc, wtComm:hccCommunityWeight, wtInst:hccInstitutionalWeigth};

				//console.log( grpName + '\t' +  groupObj[0] );// display group number and first ICD10 code...
				// DO AN IMO SEARCH FOR THE FIRST ICD10 IN EACH LIST SO WE CAN SEE WHICH HCC GROUP AND WEIGHTS THEY USE...
				//app.ImoSearchService.PerformSearch( app, {key:"1fcb1403eec6aef5",max:3, term:groupObj[0]}, function(){} );
				// RENDER THE ARRAY OF ICD CODES...
				console.log( "HCC GROUP " + grpName );
				//console.log( JSON.stringify( icdArr ) );
			}
		}
		// THIS OUTPUT BELONGS IN FILE HCC_2016.json
		console.log( JSON.stringify(outputObj));
		console.log( "END == _objICD10ArraysOrgByGroup =========");
	};


	var _updateMongo = function(){
		var dbCallback = function( err, db) {
			if (err) return;
			console.log("Writing....");
			for (var x=0; x<_hccArrForMongo.length; x++){
				var hccObj = _hccArrForMongo[x];
				var match = {"icd10":hccObj.icd10 };
				var subDoc = {"HCC_2016":hccObj.hccGrp};
				if (hccObj.hccAttrib){
					subDoc = {"HCC_2016_2":hccObj.hccGrp};
				}
				
				db.collection( "icd10" ).update( match, {"$set": subDoc }, function(err, res ){
				//db.collection( "icd10" ).update( match, {"$unset": {"hccGrp":""} }, function(err, res ){
					if (err){
						console.log( "=== ERROR ===" + x + " " + err );
						return;
					}
					else {
						if(res!=1){
	    				console.log( JSON.stringify(res) );
						}
					}
				});//end update function call....
			}		
			console.log("Done.");	
		};//end dbCallback....
		getDbConnection( dbCallback );
	};//end function....


	var _parseHCCWeightData_STEP02 = function( err, fileText ){
		if (err) return;
		console.log("START WEIGHT DATA ");
		console.log( "" );
		var lineArr = fileText.split('\|');
		for (var x=0; x<lineArr.length; x++){
			var line = lineArr[x];
			var words = line.split('^');
			var hccGroup = words[0];
			var hccDesc = words[1];
			var hccCommunityWeight = words[2];
			var hccInstitutionalWeigth = words[3];
			var hccRecord = {hcc: hccGroup, desc:hccDesc, wtComm:hccCommunityWeight, wtInst:hccInstitutionalWeigth};
			_hccGroups.push( hccRecord );
			//console.log( hccGroup + " " + hccDesc + " " + hccCommunityWeight + " " + hccInstitutionalWeigth);
		}
		//console.log( JSON.stringify(_finalHccObj));
		_display_objICD10ArraysOrgByGroup();
		console.log( "DONE");
	};

	var _fnParseICD10DataFile_STEP01 = function( err, dataTxt ){
		if (err) return; //error reading the file...
		console.log( "Parsing ICD10/HCC file...");
		var lineArr = dataTxt.split('\n');
		for (var x=0; x<lineArr.length; x++){
			var line = lineArr[x];
			var objHccIcdForMongo = {}; //{hccGrp:XX, icd10:YY, hccAttrib:"D"}
			objHccIcdForMongo.icd10 = line.substr(0,8).trim(); // FIRST 8 CHARACTERS=ICD10 CODE...
			objHccIcdForMongo.hccGrp = parseInt( line.substr(8,3).trim() );// NEXT 3 CHARACTERS = HCC GRP NUMBER...
			var attr = line.substr(12,1).trim(); //NEXT 3 CHARS ARE OPTIONAL "D" ATTRIBUTE
			if (attr.length>0){
			 	objHccIcdForMongo.hccAttrib = attr;
			}
			_hccArrForMongo.push( objHccIcdForMongo );
			
			var icdArr = _fnGetHCCGroupByNumber( objHccIcdForMongo.hccGrp );
			icdArr.push( objHccIcdForMongo.icd10 );
		}// END FOR LOOP...
		// SOME ICD10 CODES HAVE MORE THAN ONE HCC_GROUP.
		//console.log( JSON.stringify( _hccArrForMongo ) );
		//_updateMongo(); // UPDATE icd10 COLLECTION WITH HCC DATA...


		// NOW READ THE HCC DETAILS FILE WITH WEIGHTS AND DESCRIPTIONS....
		_fs.readFile( filePath_HCC_WT, 'utf8', _parseHCCWeightData_STEP02 );
	};//end function...

	// START BY READING THE FIRST
	_fs.readFile( filePath_ICD_HCC, 'utf8', _fnParseICD10DataFile_STEP01 );	
};





exports.GetIcd10Description=function( icd10Root, callback ){
	var _db_callback = function( result ){
		callback( result );
	}
	icd10Root = icd10Root.trim().toUpperCase().replace('.',"");
	var lvl = icd10Root.length;

	var collection = _icd10DescriptionCollection;
	var query = {"icd10": {"$gte":icd10Root, "$lt":icd10Root+"Z"}, "lvl":{"$gte":lvl, "$lte":lvl+1}};
	var options = {_id:0};
	genericFindRecordsInDatabase( collection, query, options, _db_callback );	
};



exports.GetProblemDuration=function( accountId, callback){
	var _db_callback = function( result ){
		callback( result );
	}
	var collection = _probDurationCollection;
	var query = {accountId: {"$in":[accountId]} };
	var options = {_id:0 };
	genericFindRecordsInDatabase( collection, query, options, _db_callback );
};



exports.GetLogicComponentsForAccount=function( accountId, callback){
	var _db_callback = function( result ){
		callback( result );
	}
	var collection = _logicCollection;
	//var query = {accountId: {"$in":["ALL", accountId]} };
	var query = { "$and": [{accountId: {"$in":["ALL", accountId]}}, {accountExclude: {"$nin":[accountId]}}]};
	var options = {_id:0, accountId:0 };
	genericFindRecordsInDatabase( collection, query, options, _db_callback );
};


exports.LoadObsHeadXml=function( filePath ){
	var parser = new _xml2js.Parser();
	this.TestDb();


	_fs.readFile(filePath, function(err, data) {
		if (err){
			return;
		}
    parser.parseString(data, function (err, result) {

	    _obsHeadJsonList = result.dataroot.TUT_OBSHEAD;

	    addObsDocumentsToCollection();
	  });
	});
};//end function.....


exports.GetFlowsheetById=function( flowsheetId, callback, bReturnAccountId ){
	var query = {_id: _ObjectID(flowsheetId) };
	var collectionName =  _flowsheetColection; 

	var returnFields = {name:1, folder:1, path:1, _id:1, data:1, accountId:1};
	if (!bReturnAccountId){
		delete returnFields.accountId; //don't show account id in client....
	}
	var dbCallback = function( err, db){
		if (err!=undefined){
			return;
		}
		var cursor = db.collection( collectionName ).find( query, returnFields );
		cursor.toArray( function( err, doc ){
			callback( doc );
		});
	};
	getDbConnection( dbCallback );	
};//end function...


exports.DeleteFlowsheetById=function( flowsheetId, callback ){
	var gotFlowsheetCallback = function( fsDoc ){
		// WE'VE FOUND THE FLOWSHEET WE WANT TO DELETE....
		if (fsDoc && fsDoc.length && fsDoc.length>0){
			var fsRecord = fsDoc[0];
			var accountId = fsRecord.accountId;
			fsRecord.oldAccountId = accountId;
			fsRecord.deleted = true;
			fsRecord.accountId = "DELETED"; // THIS WILL MAKE THE RECORD UNAVAILABLE FOR THE ACCOUNT....
			var collection = _flowsheetColection;
			var query = {_id: _ObjectID(flowsheetId) }; //find matching _id....
			genericUpdateRecordInDatabase( collection, query, fsRecord, true, callback);
		}
	}
	var dbCallback = function( err, db){
		// FAIL IF BAD DATABASE CONNECTION...
		if (err!=undefined){
			console.log(err);
			callback({"error":"Unable to connect to database"});
			return;
		}
		// GET FLOWSHEET RECORD...
		exports.GetFlowsheetById( flowsheetId, gotFlowsheetCallback, true );
	};
	getDbConnection( dbCallback );	
};


exports.removeOrder=function( order, callback ){
	var dbCallback = function( err, db){
		// FAIL IF BAD DATABASE CONNECTION...
		if (err!=undefined){
			console.log(err);
			callback({"error":"Unable to connect to database"});
			return;
		}
		//var genericRemoveRecordsInDatabase=function( collectionName, query, callback ){
		var deleteCallback = function( doc ){
			callback( doc );
		};
		if (order.accountId && order.accountId.length>2 && order.description && order.description.length>2 && order.type && order.type.length>0){
			genericRemoveRecordsInDatabase( "orders", order, deleteCallback);
		}
		else {
			callback({"error":"The order record has incorrect or missing properties."});
		}
	};
	getDbConnection( dbCallback );
};


exports.GetAccountConfig=function(accountId, callback ){
	var query = {accountId: accountId };
	var collectionName = _accountCollection;
	var returnFields = {_id:0, accountId:1, siteName:1, contact:1};
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {error: "Unable to get AccountConfig data."})
			return;
		}
		var cursor = db.collection( collectionName ).find( query, returnFields );
		cursor.toArray( function( err, doc ){
			if (doc && doc[0] ){
				callback( doc[0] );//return only the first matching record....
			}
			else{
				callback( {error:"Error trying to retrieve account config",  accountId: accountId } );
			}
		});
	};
	getDbConnection( dbCallback );
};



exports.GetUserConfig=function(accountId, loginName, callback ){
	// RETURN USER CONFIG DATA SUPPLEMENTED WITH ACCOUNT INFORMATION....
	// FETCH TWO SETS OF DATA, WAIT FOR BOTH, THEN RETURN THE RESULTS...

	var returnDocument = {}; // prep data to return to callback function...
	var _countOfResults = 0; //make sure both queries return before sending data...
	var _queryUser = {accountId: accountId, loginName: loginName };
	var _queryAcct = {accountId: accountId };
	var _returnUser = {loginName:1, config:1};
	// need to copy these values to return document below....
	//var _returnAcct = { siteName:1, subscriptions:1, contact:1, adminUsers:1, restrictedIMOModifierMenus:1 };
	var _returnAcct = { _id:0, accountId:0, status:0, cnt:0, comments:0 };//only list the items we DONT want to return....
	var _isUserBack = false;
	var _isAcctBack = false;
	var _isError = false;
	var _userResults = null;
	var _acctResults = null; 

	var finishFunction = function(){
		// TEST IF ALL DATA IS BACK....
		// CALL CALLBACK IF SO....
		if (_isError || (_isUserBack && _isAcctBack) ){
			if  (_isError){
				//returnDocument was set up in the callback functions....
				//console.log("**** ERROR ***** GetUserConfig:finishFunction() ");
			}
			else {
				// ADD USER DATA TO DOCUMENT....
				var resultArr = _userResults.resultArr;
				if (resultArr && resultArr[0] && resultArr[0].config ){
					returnDocument = resultArr[0].config;
					returnDocument.userValid="true";
				}//end if...
				else {
					returnDocument.userValid="false";
				}//end else
				// ADD ACCOUNT DATA TO THE RETURN DOCUMENT....
				resultArr = _acctResults.resultArr;
				if( resultArr && resultArr[0] ){
					var accountRecord = resultArr[0];
					returnDocument.siteName = accountRecord.siteName;  
					returnDocument.subscriptions = accountRecord.subscriptions; 
					returnDocument.adminUsers = accountRecord.adminUsers;
					returnDocument.restrictedIMOModifierMenus = accountRecord.restrictedIMOModifierMenus;
					returnDocument.contact = accountRecord.contact;	
					returnDocument.ordersCustomLists = accountRecord.ordersCustomLists;
					returnDocument.medicationCustomLists = accountRecord.medicationCustomLists;
					returnDocument.accountValid="true";			 
				}
				else {
					returnDocument.accountId=accountId;
					returnDocument.accountValid="false";
				}
			}//end else....
			//console.log( JSON.stringify(returnDocument));
			//console.log("done");
			callback( returnDocument );
		}//end if....
		else {
			//console.log("FINISH?  NOT YET...");
			//console.log( JSON.stringify(returnDocument));
		}
	};

	var accountCallback = function( result ){
		// CALLED WHEN THE ACCOUNT QUERY RETURNS WITH DATA....
		if (result.error!=null){
			_isError = true;
			returnDocument = result;
		}
		_isAcctBack = true; // account results are back....
		_acctResults = result;//STORE DATA TO ASSEMBLE LATER....
		finishFunction();
	};//end function....

	var userCallback = function( result ){
		if (result.error!=null){
			_isError = true;
			returnDocument = result;
		}
		_isUserBack = true; // user results are back....
		_userResults = result;//STORE DATA TO ASSEMBLE LATER....
		finishFunction();
	};//end function...
	//console.log("start");
	//get user data...
	genericFindRecordsInDatabase( _userCollection, _queryUser, _returnUser, userCallback );
	//get account data....
	genericFindRecordsInDatabase( _accountCollection, _queryAcct, _returnAcct, accountCallback );
};



exports.GetFlowsheetsForAccount=function( accountId, callback ){
	var query = {accountId: accountId };
	var collectionName =  _flowsheetColection; 
	var returnFields = {name:1, folder:1, path:1, _id:1 };
	var dbCallback = function( err, db){
		if (err!=undefined){
			return;
		}
		var cursor = db.collection( collectionName ).find( query, returnFields );
		cursor.toArray( function( err, doc ){
			callback( doc );
		});
	};
	getDbConnection( dbCallback );
};
exports.GetObsHeadData=function( shortNameList, callback ){
	getObsHeadData( shortNameList, callback );
};

// FETCH PROBLEM ORIENTED DISPLAY TEMPLATES MATCHING THE ICD10 ROOT CODES IN icdCodeArr 
exports.GetProblemOrientedDisplayTemplate=function( accountId, icdCodeArr, callback ){
	var dbCallback = function( err, db ){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var query = {'accountId': accountId, "criteriaArr.ICD10":{$in: icdCodeArr }};
			db.collection( "PODTemplates" ).find( query ).toArray( function( err, doc ){
				if (err){
					callback( {error: err });
				}
				else {
					callback( doc );
				}
			});
		}
	};//end dbCallback function definition....
	getDbConnection( dbCallback );
};

exports.SaveProblemOrientedDisplayTemplate=function( accountId, icd10Root, podTemplateDoc, callback ){
	var collection = "PODTemplates";
	var query = {"accountId": accountId, "criteriaArr.ICD10": icd10Root };
	genericUpdateRecordInDatabase( collection, query, podTemplateDoc, true, callback);
};


exports.GetHccData=function( icdCodeArr, callback ){
	// RETURN AN ARRAY OF HCC_ICD DATA TO callback MATCHING ALL THE ICD9 VALUES IN icd9List
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var limitReturnTo = {'_id':0,'ICD9':1,'HCC_PY_2013':1,'HCC_2013':1,'HCC_PY_2014':1,'HCC_DESC_2014':1,'HCC_2014':1};
			//var limitReturnTo = {'_id':0,'ICD9':1};
			db.collection( _hccIcd9Collection ).find( {'ICD9': {$in: icdCodeArr }}, limitReturnTo ).toArray( function(err, doc ){
			//db.collection( _hccIcd9Collection ).find( {'ICD9': icd9List[0]}, limitReturnTo ).toArray( function(err, doc ){
				if (err!=undefined){
					//console.log("ERROR");
					//console.log( icd9List[0]);
					callback( err );	
				} 
				else {
					//console.log("DONE " + icdCodeArr.length);
					//console.log( doc );
					callback( doc );
				}
			});
		}//end else if....
	};//end dbCallback function definition....
	getDbConnection( dbCallback );
};


exports.GetSystemAlerts = function( callback ){
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var limitReturnTo = {'_id':0,'alerts':1, 'mailOptions':1 };
			db.collection( _systemAlertsCollection ).find( {}, limitReturnTo ).toArray( function(err, doc ){
			//db.collection( _hccIcd9Collection ).find( {'ICD9': icd9List[0]}, limitReturnTo ).toArray( function(err, doc ){
				if (err!=undefined){
					//console.log("ERROR");
					//console.log( icd9List[0]);
					callback( err );	
				} 
				else {
					//console.log("DONE " + icdCodeArr.length);
					//console.log( doc );
					callback( doc );
				}
			});
		}//end else if....
	};//end dbCallback function definition....
	getDbConnection( dbCallback );	
};


exports.TestDb =function( ) {
	testDbConnection();
  return null;
};

	// doc_callback( err, doc)....
exports.GetDbDocument=function( docId, doc_callback ) {
	var query = {formId: docId};
	//var collectionName = _colName;

	// doc_callback( err, doc)....
	var dbCallback = function( err, db) {
		if (err!=undefined){
			return;
		}
		var cur=db.collection( collectionName ).find( query );
		cur.toArray( function(err, doc ){
			doc_callback( err, doc );
		});
	};
	getDbConnection( dbCallback );
};
exports.SaveUserConfigAttribute=function( accountId, loginName, attribute, newConfigSubDoc, callback ){
	var dbCallback = function( err, db){

		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var query = {accountId: accountId, loginName: loginName };
			var subDoc = {};
			subDoc[ "config." + attribute ] = newConfigSubDoc;
			var subDocToSave = {$set: subDoc };
			//$set: {"comments.$.type": abc}
			var upsert = {upsert:true};
			var insertCallback = function( err, cnt ){
				callback( { error: err, count: cnt } );//return results of insert to original caller....
			};//end callback...
			db.collection(  _userCollection ).update( query, subDocToSave, upsert, insertCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
};

exports.SaveAccountSubscriptionAttribute=function( accountId, loginName, attribute, newConfigSubDoc, callback ){
	// SAVE AN ATTRIBUTE OF THE SUBSCRIPTIONS PORTION OF AN ACCOUNT DOCUMENT....

	// NOT TESTED YET....

	console.log("here");
	console.log("attribute " + attribute );

	var dbCallback = function( err, db){

		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			//var query = {accountId: accountId, loginName: loginName };
			var query = { accountId: accountId };
			var subDoc = {};
			//subDoc[ "subscriptions." + attribute ] = newConfigSubDoc;
			// attribute can be something like "subscriptions.ordersCustomLists"
			subDoc[ attribute ] = newConfigSubDoc;
			var subDocToSave = {$set: subDoc };
			//$set: {"comments.$.type": abc}
			var upsert = {upsert:true};
			var insertCallback = function( err, cnt ){
				callback( { error: err, count: cnt } );//return results of insert to original caller....
			};//end callback...
			db.collection(  _accountCollection ).update( query, subDocToSave, upsert, insertCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
};


exports.SaveSubDocument=function(  query, collectionName, documentAttributeName, documentAttributeValue, callback ){
	// TESTED -- 12/17/15
	// GENERIC FUNCTION TO SAVE AN ATTRIBUTE OF THE DOCUMENT UNIQUELY IDENTIFIED BY query....
	// query should be a mongo query selector such as {"accountId:":"XXXX", "loginName":"YYYY"};
	// collectionName should be a valid collection....
	// documentAttributeName is the attribute to save the sub-document to
	// documentAttributeValue is the entire subdocument to be saved....
	//console.log("SaveSubDocument");
	//console.log( adminUserArray );
	var dbCallback = function( err, db){
		if (err!=undefined){
			console.log("ERROR GETTING DB:" + err);
			callback( {"error":"No DB connection"});
		}
		else{
			var subDoc = {};
			subDoc[ documentAttributeName ] = documentAttributeValue;
			var subDocToSave = {$set: subDoc };
			var upsert = {upsert:true};
			var insertCallback = function( err, cnt ){
				callback( { error: err, count: cnt } );//return results of insert to original caller....
			};//end callback...
			db.collection(  collectionName ).update( query, subDocToSave, upsert, insertCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
};



exports.SaveOrdersData=function( accountId, ordersData, ordersType, isFirstPayload, callback ){
	// if isFirstPayload==true, overwrite the orders documents for this account of this ordersType,
	// otherwise, supplement the orders, depending on which was submitted....

	var collection = _ordersCollection;

	var saveData = function(){
		genericInsertRecordsInDatabase( collection, ordersData, callback );		
	}//end function....

	var removeThenSaveData=function(){
		var query = {accountId: accountId, type: ordersType };
		var removeCallback = function( doc ){
			if (doc.error==null){
				saveData();
			}
		}
		genericRemoveRecordsInDatabase( collection, query, removeCallback );
	}

	if (isFirstPayload){
		//remove data, then save data...
		removeThenSaveData();
	}
	else {
		saveData();
	}

};

exports.GetOrdersData=function( accountId, _db_callback ){
	var collection = _ordersCollection;
	var query = {"accountId": accountId };
	//var options = { };
	var options = {_id:0 };
	genericFindRecordsInDatabase( collection, query, options, _db_callback );	
};

exports.saveProblemDurationData=function( accountId, probDurationDoc, callback ){
	var collection = "problem_duration";
	var query = {"accountId": accountId};
	genericUpdateRecordInDatabase( collection, query, probDurationDoc, true, callback);
};


var genericFindRecordsInDatabase=function( collectionName, query, options, callback ){
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var actionCallback = function( err, result ){

				if (err==null){
					result.toArray( function(err,doc){ //unwrap the result cursor into an array of records....
						if (err==null){ 
							callback( { error: null, resultArr: doc } );//return results of insert to original caller....
						}
						else {
							callback( {error: err, result: null } );
						}
					});
				}//end if...
			};//end callback...
			var cursor = db.collection( collectionName ).find( query, options, actionCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
}

var genericInsertRecordsInDatabase=function( collectionName, data, callback ){
	// INSERT OR REPLACE A FULL RECORD IN THE DATABASE....
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var actionCallback = function( err, result ){
				callback( { error: err, result: result } );//return results of insert to original caller....
			};//end callback...
			db.collection( collectionName ).insert( data, {}, actionCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
}



var genericUpdateRecordInDatabase=function( collectionName, query, record, isUpsert, callback ){
	// INSERT OR REPLACE A FULL RECORD IN THE DATABASE....
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var upsert = {upsert:true};
			if( !isUpsert){
				upsert = {};
			}
			var actionCallback = function( err, cnt ){
				callback( { error: err, count: cnt } );//return results of insert to original caller....
			};//end callback...
			db.collection( collectionName ).update( query, record, upsert, actionCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
}

var genericRemoveRecordsInDatabase=function( collectionName, query, callback ){
	// INSERT OR REPLACE A FULL RECORD IN THE DATABASE....
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var actionCallback = function( err, cnt ){
				callback( { error: err, count: cnt } );//return results of insert to original caller....
			};//end callback...
			db.collection( collectionName ).remove( query, {}, actionCallback );
		}//end else if....		

	};//end callback...
	getDbConnection( dbCallback);
}





exports.SaveFlowsheetClinicalKits=function( flowsheetCktArr, accountId, callback ){
	//FIRST, ITERATE THROUGH FLOWSHEETS AND LOOKUP THE OBS SHORTNAME FOR EACH HDID PROVIDED....
	if ( flowsheetCktArr==undefined || flowsheetCktArr==null || flowsheetCktArr.length==undefined ){
		callback( {"error": "Flowsheet array is undefined or null"});
	}


	var hdidArr = [];// create array of hdid values which we can use to lookup the OBSHEAD information...

	//skip the two placeholder strings added to the array before it was pushed to the server....
	flowsheetCktArr.splice(0, 2);//remove the first two placeholders...
	for (var i=0; i<flowsheetCktArr.length; i++){
		var flowsheetCktItem = flowsheetCktArr[i];
		//flowsheetCktItem = JSON.parse(flowsheetCktItem);
		//flowsheetCktArr[i] = flowsheetCktItem; //save the parsed object, so we don't have to do it again below....
		//var name = flowsheetCktItem.name;// string...
		//var path = flowsheetCktItem.path;// string array of 'folder names'...
		var data = flowsheetCktItem.data;// obj array: {"hdid":"2558","label":""}...
		for (h=0; h<data.length; h++){
			var fsDataObj = data[h];
			hdidArr.push( fsDataObj.HDID );
		}//end for loop - h....
	}//end for loop - i....
	// NOW hdidArr contains all hdid values...
	// DEFINE CALLBACK FOR ONCE ALL THE OBS HEAD DATA HAS BEEN LOOKED UP.....
	var getHdid_callback = function( obsHeadArr ){
		for (var i=0; i<flowsheetCktArr.length; i++){
			var flowsheetCktItem = flowsheetCktArr[i];
			flowsheetCktItem.accountId=accountId; //store the account id with each flowsheet.
			flowsheetCktItem.folder=flowsheetCktItem.path.join("/");//save the folder heirarcy as a string...
			//var name = flowsheetCktItem.name;// string...
			//var path = flowsheetCktItem.path;// string array of 'folder names'...
			var data = flowsheetCktItem.data;// obj array: {"hdid":"2558","label":""}...
			for (h=0; h<data.length; h++){
				var fsDataObj = data[h];
				hdid = fsDataObj.HDID;
				var obsRecord = lookupObsHeadRecordMatchingHdid( obsHeadArr, hdid );
				if( obsRecord==null){
					fsDataObj.error = "NO MATCHING OBS HEAD INFO";
				}
				else {
					fsDataObj.OBSHEAD = obsRecord;
					delete fsDataObj.HDID; // don't need this attribute anymore if the OBSHEAD is present....
					data[h] = fsDataObj; //save updated flowsheet record....
				}
			}//end for loop - h....
		}//end for loop - i....
		// SAVE THE FLOWSHEETS TO THE DATABASE....
		var saveToDb_callback = function( saveResults ){
			callback( saveResults );
		};//end callback....
		saveFlowsheetsToDatabase( flowsheetCktArr, saveToDb_callback );
	};//end callback function....
	getObsHeadDataByHdid( hdidArr, getHdid_callback );//inititate database lookup of HDID values....
};


var saveFlowsheetsToDatabase=function( flowsheetArr, resultCallback ){

		var dbCallback = function( err, db){
			var noOfFlowsheets = flowsheetArr.length;
			var noOfDatabaseCallbacks = 0;//we are done when this increases to match the number of flowsheets...
			var dbInsertResultsArr = [];

			for (var i=0; i<flowsheetArr.length; i++){
				var flowsheet = flowsheetArr[i];
				var name = flowsheet.name;
				var accountId = flowsheet.accountId;
				var folder = flowsheet.path.join("/");

				if (err!=undefined){
					console.log("ERROR GETTING DB:" + err);
					callback( {"error":"No DB connection"});
				}
				else{
					var query = {accountId: accountId, folder:folder, name: name };
					var upsert = {upsert:true};
					var insertCallback = function( err, cnt ){
						dbInsertResultsArr.push({error: err, count: cnt});
						noOfDatabaseCallbacks ++;
						if (noOfDatabaseCallbacks == noOfFlowsheets){ //They've all been saved...
							resultCallback( dbInsertResultsArr );//return results of insert to original caller....
						}
					};//end callback...
					db.collection(  _flowsheetColection ).update( query, flowsheet, upsert, insertCallback );
				}//end else if....		

			}//end for loop....
		};//end callback...
		getDbConnection( dbCallback);
};//end function....












var lookupObsHeadRecordMatchingHdid=function( obsHeadArr, hdid ){
	// return matching obsHead record matching the supplied hdid value....
	for (var x = 0; x<obsHeadArr.length; x ++ ){
		var obsRecord = obsHeadArr[x];
		var recordHdid = obsRecord.HDID;
		if (recordHdid==hdid){
			return obsRecord;
		}//end if...
	}//end for x....
	return null;
}//end function...

var getObsHeadDataByHdid=function( hdidArr, callback ){
	// RETURN AN ARRAY OF OBSHEAD DATA TO callback MATCHING ALL THE HDID STRING VALUES IN hdidArr
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			var limitReturnTo = {'_id':0,'HDID':1,'NAME':1,'DESCRIPTION':1,'UNIT':1,'OBSTYPE':1,'KEYWORD':1};
			db.collection( _colName ).find( {'HDID': {$in: hdidArr }}, limitReturnTo ).toArray( function(err, doc ){
				if (err!=undefined) callback( err );
				callback( doc );
			});
		}//end else if....
	};//end dbCallback function definition....
	getDbConnection( dbCallback );
};




var getObsHeadData=function( shortNameList, callback ){
	// RETURN AN ARRAY OF OBSHEAD DATA TO callback MATCHING ALL THE SHORTNAME STRING VALUES IN shortNameList
	var dbCallback = function( err, db){
		if (err!=undefined){
			callback( {"error":"No DB connection"});
		}
		else{
			//callback( shortNameList );
			var limitReturnTo = {'_id':0,'HDID':1,'NAME':1,'DESCRIPTION':1,'UNIT':1,'OBSTYPE':1,'KEYWORD':1};
			db.collection( _colName ).find( {'NAME': {$in: shortNameList }}, limitReturnTo ).toArray( function(err, doc ){
				if (err!=undefined){
					callback( err );	
				} 
				else {
					callback( doc );
				}
			});
		}//end else if....
	};//end dbCallback function definition....
	getDbConnection( dbCallback );
};




var addObsDocumentsToCollection=function( ){

	var dbCallback = function( err, db) {
		if (err!=undefined){
			return;
		}

    for( var x=0; x<_obsHeadJsonList.length; x++){
    	var obs = _obsHeadJsonList[x];
    	for (var key in obs) {
    		if (obs[key].length==1) obs[key] = obs[key][0];//remove array format....
			}//end for....
			if (obs.XID="100000000000000000000000000000000000") obs.XID=null;

			var match = {"HDID": obs.HDID };
			var options = {"upsert":true};
			db.collection( _colName ).update( match, obs, options, function(err, res ){
				if (err!=undefined){
					return;
				}
				else {
				}
			});//end update function call....
    }//end for loop
	};
	getDbConnection( dbCallback );	
};


var getDbConnection=function( collectionCallback ){
	if (_dbConnection!=null){
		collectionCallback( null, _dbConnection);
		return;
	}
	var dbConnect_callback=function( err, db ){
		if (db!=null){
			_dbConnection = db;
		}
		collectionCallback( err, db );
	};
	console.log( "TRYING TO CONNECT TO DATABASE...");
	_dbClient.connect( _dbConnStr , dbConnect_callback);
};//end function.....





var testDbConnection = function(){
	// Do a simple find on 'stuff' and write all documents to console....
	var dbCallback = function( err, db){
		if (err!=undefined){
		}
		if (db==undefined) {
			return;
		}
		// HERE IS THE QUERY....
		//var cur= db.collection('stuff').find({});
		db.collection('stuff').find({}).toArray(function(err, documents) {
			if (documents.length>0){
				console.log( JSON.stringify(documents[0]));
			}
		});



	};//end dbCallback...
	getDbConnection( dbCallback );
};//end function



